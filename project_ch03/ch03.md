# 챕터 03
스프링 컨테이너를 활용해 DI(의존 주입)을 경험해보는 프로젝트

## v1
스프링 없이 순수 자바만을 이용해 회원가입 서비스 구현
회원가입 정보에 접근하는 MemberDao 클래스는 DB연동 대신 HashMap을 사용해 회원가입 정보 저장
src/resource/commandList.txt 파일에 적인 여러 줄의 명령어를 읽어와 프로그램 진행
(원래 키보드로 명령어를 입력받고 싶었으나, 구름ide에선 이상하게 안됨)

### 클래스
🎁 spring
Member: id, 이메일, 암호, 이름, 가입날짜를 저장
    changePassword 메소드를 통해 비밀번호 변경 가능
MemberDao: HashMap<String, Member> map을 이용해 회원가입 정보 읽고 쓰기 가능
    selectByEmail(이메일 값-즉, map의 키값-으로 Member 객체 리턴), insert(삽입, id설정), update(객체 변경) 메소드 존재
RegisterRequest: 회원가입 요청 정보를 담은 클래스
    isPasswordEqualToConfirmPassword 메소드를 통해 암호와 암호확인이 일치하는지 확인가능(boolean 타입)
MemberRegisterService: 실질적으로 회원가입 처리를 진행하는 클래스
    Regist 메소드를 통해 인수로 넘어온 RegisterRequest 객체의 정보를 이용해
    회원가입 진행
ChangePasswordService: 실질적으로 비밀번호 변경을 진행하는 클래스
    이메일 정보를 바탕으로 MemberDao 객체로 Member 객체를 불러온 뒤
    Member.changePassowrd 메소드 이용해 비밀번호 변경
    
🎁 assembler
Assembler: MemberRegisterService, ChangePasswordService 타입의 필드를 가져
    생성자에서 필드를 초기화하고 각 게터 메소드로 객체 반환하는 역할
    
🎁 mainPackage
MainForAssembler: main 메소드에서 프로그램의 전체적인 로직 수행


## v2
assembler 대신 스프링 컨테이너를 이용해 회원가입 서비스 구현

### 의존 주입(Dependency Injection, DI)
#### 의존
- 클래스 A가 (기능 구현을 위해) 클래스 B의 메서드를 실행할 때 A가 B에 '의존'한다고 표현
- A 클래스에 B 타입의 필드가 존재하는 경우 A가 B의 메서드 실행가능(A에 B가 없으면 기능 수행시 B 객체를 그때그때 생성 및 전달해야 해서 불편)
- A는 B의 변경(메소드명 등)에 영향을 받음
#### (한 클래스에서) 의존하는 대상을 구하는 법
1. 의존 객체를 직접 생성(생성자를 통해)
2. __의존 주입__(스프링과 관련)
3. 서비스 로케이터
#### 의존 주입의 장점: 변경의 유연함
의존 대상 객체가 원래의 상속 객체로 변경됐을 때 실제 객체를 생성하는 곳만 변경하여 해당 의존 객체가 필요한 곳에 주입하면 되므로 유지보수 편함

#### 의존 주입 방법
1. 생성자 주입
2. 세터 메소드 주입
