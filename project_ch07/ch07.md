# AOP 프로그래밍
## 프로젝트 의존성
```groovy
dependencies {
    implementation 'org.springframework:spring-context:5.0.2.RELEASE'
    //  AspectjWeaver 의존성 추가
    implementation 'org.aspectj:aspectjweaver:1.8.13'
}
```
스프링이 AOP를 구현할 때 AspectjWeaver 의존성을 사용한다고 함
- AOP 관련 어노테이션 사용할 때 필요

### 스프링 내 AOP 기능
- spring-aop 모듈이 스프링 프레임워크의 AOP 기능을 제공
  - spring-context 모듈이 spring-aop 모듈에 의존하므로 build.gradle에 추가할 필요 없음
- 다만, AOP 관련 기능을 편하게 사용하고 싶다면 aspectjweaver 모듈을 사용하면 좋음
  -  AOP 설정에 필요한 어노테이션을 제공하기 때문

## 프록시와 AOP
### AOP(Aspect Oriented Programming)
- 여러 객체에 공통으로 적용할 수 있는 기능을 분리해 재사용성을 높이는 프로그래밍 기법
- 핵심 기능과 공통 기능의 구현을 분리함으로써, 핵심 기능 코드의 수정 없이 공통 기능 적용 가능
  - 핵심 기능: 본래 클래스의 메서드가 정의된 핵심적인 목적(수행하는 기능)
  - 공통 기능: 여러 메서드에 공통으로 추가하고 싶은 기능

#### AOP 적용 방식
- 컴파일 시점에 코드에 공통 기능 삽입
- 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
- 런타임에 프록시 객체를 생성해 공통 기능 삽입
> - 스프링 AOP에서는 세 번째 방법(프록시)만을 지원
> - 나머지 두 가지 방법은 Aspectj 등의 AOP 전용 도구를 사용해 적용 가능

### 프록시(Proxy)
- 핵심 기능의 실행은 다른 객체에게 **위임**하고 부가적인 기능을 제공하는 객체
  - 여러 객체에 공통으로 적용할 수 있는 기능을 구현
- 실제 핵심 기능을 수행하는 객체 -> **대상 객체**

### AOP 주요 용어
| 용어        | 의미                                                                      |
|-----------|-------------------------------------------------------------------------|
| Advice    | 언제 공통 기능을 핵심 로직에 적용할 것인가를 정의한 것                                         |
| Joinpoint | Advice를 적용 가능한 지점<br/>스프링은 프록시에 대한 AOP만을 구현하므로 메서드 호출에 대한 Joinpoint만 지원 |
| Pointcut  | Joinpoint 중, 실제 Advice가 적용되는 Joinpoint                                  |
| Weaving   | Advice를 핵심 로직 코드에 적용하는 행위                                               |
| Aspect    | 여러 공통 객체에 공통으로 적용되는 기능<br/>ex) 트랜잭션, 보안                                 |
### 스프링에서 구현 가능한 Advice 종류
| 종류                     | 설명                                                                            |
|------------------------|-------------------------------------------------------------------------------|
| Before Advice          | 대상 객체의 메서드 호출 전에 공통 기능 수행                                                     |
| After Returning Advice | 대상 객체의 메서드가 **익셉션 없이 실행된 후**(즉 정상 리턴 후) 공통 기능 수행                              |
| After Throwing Advice  | 대상 객체의 메서드 실행 도중 **익셉션이 발생한 경우** 공통 기능 실행                                     |
| After Advice           | 익셉션 발생 여부 상관 없이 대상 객체 메서드 실행 후 공통 기능 실행                                       |
| Around Advice          | 대상 객체의 메서드 실행 전후, 익셉션 발생 시점에 공통 기능 실행하는 데 사용<br/>다양한 시점에 원하는 기능 삽입 가능하여 널리 사용 |

## 스프링 AOP 활용
- 스프링 AOP는 프록시를 자동으로 생성하므로 우리가 프록시를 구현할 필요가 없음
    - 공통 기능을 구현한 클래스만 알맞게 구현하면 됨
### 공통 기능 정의
- Aspect로 사용할 클래스에 `@Aspect` 어노테이션 적용
- `@Pointcut` 어노테이션으로 공통 기능을 적용할 Pointcut 정의
  - 속성값에 해당하는 표현식을 Pointcut으로 지정
  - 메서드에 어노테이션 적용시 메서드 이름을 통해 Pointcut 재활용 가능
- 공통 기능을 구현한 메서드에 `@Around` 어노테이션 적용
  - 속성값에 해당하는 포인트컷의 실행 전후에 공통 기능을 적용하겠단 의미
  - 속성값에는 Pointcut 표현식 또는 `@Pointcut` 어노테이션이 적용된 메서드를 넣음
#### [Pointcut 표현식]
- 표현식은 Pointcut 지시자로 시작됨
  - 메서드, 타입, 어노테이션 등을 Pointcut으로 설정 가능
  - 스프링 aop에서 가장 많이 사용하는 지시자는 **execution**
  - 메서드를 실행한 경우를 Joinpoint로 지정
##### execution 지시자를 이용한 표현식 구조
```
execution([수식어패턴] 리턴타입패턴 [클래스이름패턴]메서드이름패턴(파라미터패턴))
```
- 수식어패턴(생략 가능): public, private 등 접근지정자 의미
  - 스프링 aop에선 public 메서드만 지원하므로 사실상 의미 없음
- 리턴타입패턴: 메서드의 리턴 타입을 의미
- 클래스이름패턴(생략 가능): 패키지 및 클래스 이름을 의미
  - 클래스이름 패턴에서의 ..은 특정 패키지 및 그 하위 패키지를 의미
- 메서드이름패턴: 클래스이름패턴이 존재한다면 .으로 이어 표현
- 파라미터패턴: 파라미터의 타입을 의미
  - ex) "Integer, *": 첫 파라미터가 Integer형, 두 번째 파라미터는 모든 타입을 의미
  - 파라미터 패턴에서의 ..은 0개 이상의 모든 타입의 파라미터를 의미
```
execution(public * chap07..*(..))
```
- 접근지정자가 public이고 모든 리턴 타입의 chap07 및 하위 패키지의 모든 메서드가 실행되는 순간을 Pointcut으로 지정하는 표현식
- *은 모든 값을 의미
#### [ProceedingJoinPoint 클래스]
- 공통 기능을 하는 메서드(예를 들어 `@Around`가 붙은)에 필요한 파라미터
- `proceed()` 메서드를 실행하면 프록시 대상 객체의 메서드를 실행한 것과 동일
  - 대상 객체 메서드의 리턴값을 Object 타입으로 반환
  - Around Advice의 경우 이 메서드 실행 전후에 공통 기능을 배치
- `getSignature()`는 호출한 메서드의 시그니처(메서드 이름, 파라미터의 타입 및 개수)를 Signature 타입으로 반환
- `getTarget()`은 프록시 대상 객체를 Object 타입으로 리턴
- `getArgs()`은 대상 객체 메서드로 전달된 인자를 배열 형태로 리턴`

### 정의한 공통 기능 활성화
- 설정 클래스에 Aspect 클래스를 빈으로 등록
- 설정 클래스에 `@EnableAspectJAutoProxy` 어노테이션 적용
  - 그래야 스프링이 `@Aspect`가 붙은 빈 객체를 찾아 내용 확인 후 공통 기능 적용
> Enable로 시작하는 어노테이션은 복잡한 스프링 설정을 간편하게 적용하는 역할
> - `@EnableAsepctJAutoProxy`는 `AnnotationAwareAspectJAutoProxyCreator` 객체를 빈으로 등록
## 프록시 생성 및 실행
### 프록시 실행 과정
1. 대상 객체의 메서드를 실행 
2. 알고 보니 대상 객체와 연결된 프록시의 메서드를 대신 실행
3. 프록시 내에서 Aspect 클래스의 `@Around`(등의 advice를 의미하는) 메서드 실행
4. `@Around` 메서드 내에서 공통 기능 수행하면서 `ProceedingJoinPoint.proceed()`를 통해 핵심 기능 실행
5. 실행이 끝나면 호출 순서의 반대로 리턴하면서 대상 객체의 메서드를 실행한 부분으로 복귀
> 스프링 AOP를 적용한 뒤 `대상객체.getClass().getName()` 값을 확인하면 대상 객체의 클래스가 아닌 프록시의 클래스 이름이 반환됨
> - 현재 상황에선 `com.sun.proxy.$Proxy17`로 확인되는데 이 값은 자바나 스프링 버전에 따라 달라짐
> - Aspect 타입 빈을 주석 처리한 뒤 다시 값을 확인하면 대상 객체 클래스 이름이 제대로 반환됨
### 프록시 생성 방식
- 기본적으로 프록시를 생성할 때 대상 객체(빈)의 실제 타입이 아닌, 대상 객체가 구현한 인터페이스(빈 메서드의 리턴 타입)를 이용해 프록시 생성
  - 프로젝트 예제에서 calculator 빈에 대한 프록시는 `Calculator` 타입에는 해당되지만, `RecCalculator` 타입에는 해당되지 않음
> [참고] 스프링 컨테이너는 빈의 이름과 빈 객체를 연결해 맵 형태로 저장
> - `getBean()` 내에 빈 메서드가 리턴하는 타입의 인터페이스가 아닌, 빈 메서드가 실제로 리턴하는 타입을 넣어도 빈을 얻을 수 있음
> - 프로젝트 예제에서 Aspect 빈을 등록하지 않은 경우, calculator 빈은 `RecCalculator`로 타입 변환이 가능하므로 `ctx.getBean(RecCalculator.class)`을 통해서도 calculator 빈을 얻을 수 있음
- 인터페이스가 아닌 자바 클래스를 상속받아 프록시를 생성하고 싶다면 `@EnableAspectJAutoProxy`의 proxyTargetClass 속성을 `true`로 지정
## Advice 적용 순서
- 스프링, 자바 버전에 따라 다름
  - (추측)현재 환경에선 AppCtx에서 Aspect 빈을 정의한 순서랑 연관이 있나 싶은데 확실하진 않음
- 적용 순서가 중요한 경우 `@Order` 어노테이션을 Aspect 클래스에 적용
  - 어노테이션에 속성값으로 전달한 정수 크기가 작을수록 먼저 적용(오름차순)
  - 적용 순서를 고려하지 않는 경우, 대상 객체의 메서드를 실행하지 않고 넘어가는 경우가 생길 수 있으므로 적용 순서를 고려해야 함
    - 공통 기능 내에서 대상 객체를 호출할 때 조건 분기가 존재하는 경우
> `ExeTimeAspect`의 Order 값을 1, `CacheAspect`의 Order 값을 2로 지정했을 때
> - `@Order` 어노테이션에 의해 `ExeTimeAspect` 프록시의 대상 객체는 `CacheAspect` 프록시,
> `CacheAspect` 프록시의 대상 객체는 실제 객체가 됨
> - 그래서 빈의 `factorial()`을 실행했을 때 `ExeTimeAspect` 프록시에 먼저 접근하고, 나중에 `CacheAspect` 프록시에 접근