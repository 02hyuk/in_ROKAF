# AOP 프로그래밍
## 프로젝트 의존성
```groovy
dependencies {
    implementation 'org.springframework:spring-context:5.0.2.RELEASE'
    //  AspectjWeaver 의존성 추가
    implementation 'org.aspectj:aspectjweaver:1.8.13'
}
```
스프링이 AOP를 구현할 때 AspectjWeaver 의존성을 사용한다고 함
- AOP 관련 어노테이션 사용할 때 필요

### 스프링 내 AOP 기능
- spring-aop 모듈이 스프링 프레임워크의 AOP 기능을 제공
  - spring-context 모듈이 spring-aop 모듈에 의존하므로 build.gradle에 추가할 필요 없음
- 다만, AOP 관련 기능을 편하게 사용하고 싶다면 aspectjweaver 모듈을 사용하면 좋음
  -  AOP 설정에 필요한 어노테이션을 제공하기 때문

## 프록시와 AOP
### AOP(Aspect Oriented Programming)
- 여러 객체에 공통으로 적용할 수 있는 기능을 분리해 재사용성을 높이는 프로그래밍 기법
- 핵심 기능과 공통 기능의 구현을 분리함으로써, 핵심 기능 코드의 수정 없이 공통 기능 적용 가능
  - 핵심 기능: 본래 클래스의 메서드가 정의된 핵심적인 목적(수행하는 기능)
  - 공통 기능: 여러 메서드에 공통으로 추가하고 싶은 기능

#### AOP 적용 방식
- 컴파일 시점에 코드에 공통 기능 삽입
- 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
- 런타임에 프록시 객체를 생성해 공통 기능 삽입
> - 스프링 AOP에서는 세 번째 방법(프록시)만을 지원
> - 나머지 두 가지 방법은 Aspectj 등의 AOP 전용 도구를 사용해 적용 가능

### 프록시(Proxy)
- 핵심 기능의 실행은 다른 객체에게 **위임**하고 부가적인 기능을 제공하는 객체
  - 여러 객체에 공통으로 적용할 수 있는 기능을 구현
- 실제 핵심 기능을 수행하는 객체 -> **대상 객체**

### AOP 주요 용어
| 용어        | 의미                                                                      |
|-----------|-------------------------------------------------------------------------|
| Advice    | 언제 공통 기능을 핵심 로직에 적용할 것인가를 정의한 것                                         |
| Joinpoint | Advice를 적용 가능한 지점<br/>스프링은 프록시에 대한 AOP만을 구현하므로 메서드 호출에 대한 Joinpoint만 지원 |
| Pointcut  | Joinpoint 중, 실제 Advice가 적용되는 Joinpoint                                  |
| Weaving   | Advice를 핵심 로직 코드에 적용하는 행위                                               |
| Aspect    | 여러 공통 객체에 공통으로 적용되는 기능<br/>ex) 트랜잭션, 보안                                 |
### 스프링에서 구현 가능한 Advice 종류
| 종류                     | 설명                                                                            |
|------------------------|-------------------------------------------------------------------------------|
| Before Advice          | 대상 객체의 메서드 호출 전에 공통 기능 수행                                                     |
| After Returning Advice | 대상 객체의 메서드가 **익셉션 없이 실행된 후**(즉 정상 리턴 후) 공통 기능 수행                              |
| After Throwing Advice  | 대상 객체의 메서드 실행 도중 **익셉션이 발생한 경우** 공통 기능 실행                                     |
| After Advice           | 익셉션 발생 여부 상관 없이 대상 객체 메서드 실행 후 공통 기능 실행                                       |
| Around Advice          | 대상 객체의 메서드 실행 전후, 익셉션 발생 시점에 공통 기능 실행하는 데 사용<br/>다양한 시점에 원하는 기능 삽입 가능하여 널리 사용 |

## 스프링 AOP 활용
- 스프링 AOP는 프록시를 자동으로 생성하므로 우리가 프록시를 구현할 필요가 없음
    - 공통 기능을 구현한 클래스만 알맞게 구현하면 됨
### 공통 기능 정의
- Aspect로 사용할 클래스에 `@Aspect` 어노테이션 적용
- `@Pointcut` 어노테이션으로 공통 기능을 적용할 Pointcut 정의
  - 속성값에 해당하는 표현식을 Pointcut으로 지정
  - 메서드에 어노테이션 적용시 메서드 이름을 통해 Pointcut 재활용 가능
- 공통 기능을 구현한 메서드에 `@Around` 어노테이션 적용
  - 속성값에 해당하는 포인트컷의 실행 전후에 공통 기능을 적용하겠단 의미
  - 속성값에는 Pointcut 표현식 또는 `@Pointcut` 어노테이션이 적용된 메서드를을 넣음
#### Pointcut 표현식
- 표현식은 Pointcut 지시자로 시작됨
  - 메서드, 타입, 어노테이션 등을 Pointcut으로 설정 가능
  - 스프링 aop에서 가장 많이 사용하는 지시자는 **execution**
  - 메서드를 실행한 경우를 Joinpoint로 지정
##### execution 지시자를 이용한 표현식 구조
> execution([수식어패턴] 리턴타입패턴 [클래스이름패턴]메서드이름패턴(파라미터패턴))
- 수식어패턴(생략 가능): public, private 등 접근지정자 의미
  - 스프링 aop에선 public 메서드만 지원하므로 사실상 의미 없음
- 리턴타입패턴: 메서드의 리턴 타입을 의미
- 클래스이름패턴(생략 가능): 패키지 및 클래스 이름을 의미
  - 클래스이름 패턴에서의 ..은 특정 패키지 및 그 하위 패키지를 의미
- 메서드이름패턴: 클래스이름패턴이 존재한다면 .으로 이어 표현
- 파라미터패턴: 파라미터의 타입을 의미
  - ex) "Integer, *": 첫 파라미터가 Integer형, 두 번째 파라미터는 모든 타입을 의미
  - 파라미터 패턴에서의 ..은 0개 이상의 모든 타입의 파라미터를 의미
> execution(public * chap07..*(..))
- 접근지정자가 public이고 모든 리턴 타입의 chap07 및 하위 패키지의 모든 메서드가 실행되는 순간을 Pointcut으로 지정하는 표현식
- *은 모든 값을 의미


### 정의한 공통 기능 활성화
- 설정 클래스에 Aspect 클래스를 빈으로 등록
- 설정 클래스에 `@EnableAspectJAutoProxy` 어노테이션 적용
  - 그래야 스프링이 `@Aspect`가 붙은 빈 객체를 찾아 내용 확인 후 공통 기능 적용
> - Enable로 시작하는 어노테이션은 복잡한 스프링 설정을 간편하게 적용하는 역할
> - `@EnableAsepctJAutoProxy`는 `AnnotationAwareAspectJAutoProxyCreator` 객체를 빈으로 등록

다음에 정리할 내용> Advice 적용 순서, 프록시 생성 방식. ProceedingJoinPoint 클래스, 프록시 실행 과정